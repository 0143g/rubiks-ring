<!DOCTYPE html>
<html>
<head>
    <title>GAN Cube Native Controller</title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script type="module" src="https://cdn.cubing.net/v0/js/cubing/twisty"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js"
        }
    }
    </script>
    <style>
        body { font-family: system-ui, -apple-system, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; }
        .header { background: white; padding: 20px; border-radius: 10px; margin-bottom: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .status { padding: 15px; margin: 10px 0; border-radius: 8px; font-weight: bold; }
        .connected { background: #d4edda; border: 1px solid #c3e6cb; color: #155724; }
        .disconnected { background: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; }
        .scanning { background: #fff3cd; border: 1px solid #ffeaa7; color: #856404; }
        
        .cube-3d-container { background: white; padding: 20px; border-radius: 10px; margin-bottom: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); text-align: center; }
        .cube-3d-viewer { width: 100%; height: 300px; border-radius: 8px; overflow: hidden; margin: 0 auto; display: flex; justify-content: center; align-items: center; }
        #cube-twisty-player { display: flex; justify-content: center; align-items: center; width: 100%; height: 100%; }
        twisty-player { margin: 0 auto; }
        .dashboard { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        .panel { background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        
        .gyro-display { font-family: monospace; }
        .gyro-item { display: flex; justify-content: space-between; margin: 8px 0; padding: 8px; background: #f8f9fa; border-radius: 5px; }
        .gyro-label { font-weight: bold; color: #666; }
        .gyro-value { color: #333; }
        
        .cube-info { }
        .cube-info .info-item { display: flex; justify-content: space-between; margin: 8px 0; padding: 8px; background: #f8f9fa; border-radius: 5px; }
        .cube-info .label { font-weight: bold; color: #666; }
        .cube-info .value { color: #333; }
        
        .log { background: #f8f9fa; border: 1px solid #dee2e6; padding: 15px; height: 200px; overflow-y: scroll; border-radius: 8px; font-family: monospace; font-size: 14px; }
        .log-entry { margin: 2px 0; }
        
        button { padding: 12px 24px; margin: 5px; font-size: 16px; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; }
        button:hover { opacity: 0.9; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        #connectCube { background: #28a745; color: white; }
        #scanCubes { background: #007bff; color: white; }
        #connectBridge { background: #6f42c1; color: white; }
        #resetOrientation { background: #ffc107; color: #212529; }
        #disconnect { background: #dc3545; color: white; }
        
        h1 { margin: 0 0 20px 0; color: #333; }
        h3 { margin: 0 0 15px 0; color: #555; }
        
        .activity-indicator { width: 12px; height: 12px; border-radius: 50%; display: inline-block; margin-left: 10px; }
        .active { background: #28a745; animation: pulse 1s infinite; }
        .inactive { background: #6c757d; }
        .scanning-indicator { background: #ffc107; animation: pulse 1s infinite; }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .cube-list { margin: 15px 0; }
        .cube-item { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            padding: 10px; 
            margin: 5px 0; 
            background: #f8f9fa; 
            border-radius: 5px; 
            border: 1px solid #dee2e6; 
        }
        .cube-item button { 
            padding: 5px 10px; 
            font-size: 14px; 
            background: #007bff; 
            color: white; 
        }
        .cube-details { font-family: monospace; font-size: 14px; color: #666; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>GAN Cube Native Controller<span class="activity-indicator inactive" id="activityIndicator"></span></h1>
            
            <div id="status" class="status disconnected">
                status: disconnected
            </div>
            
            <button id="connectCube">Connect Cube</button>
            <button id="scanCubes">Scan for Cubes</button>
            <button id="connectBridge">Connect Controller Bridge</button>
            <button id="resetOrientation">Reset Orientation</button>
            <button id="disconnect">Disconnect</button>
            
            <div id="cubeList" class="cube-list" style="display: none;">
                <h4>Available Cubes:</h4>
                <div id="cubeItems"></div>
            </div>
        </div>
        
        <div class="cube-3d-container">
            <h3>Real-time Cube Visualization</h3>
            <div id="cube-twisty-player" class="cube-3d-viewer"></div>
        </div>
        
        <div class="dashboard">
            <div class="panel">
                <h3>Cube Orientation</h3>
                <div class="gyro-display">
                    <div class="gyro-item">
                        <span class="gyro-label">quaternion x:</span>
                        <span class="gyro-value" id="quatX">0.000</span>
                    </div>
                    <div class="gyro-item">
                        <span class="gyro-label">quaternion y:</span>
                        <span class="gyro-value" id="quatY">0.000</span>
                    </div>
                    <div class="gyro-item">
                        <span class="gyro-label">quaternion z:</span>
                        <span class="gyro-value" id="quatZ">0.000</span>
                    </div>
                    <div class="gyro-item">
                        <span class="gyro-label">quaternion w:</span>
                        <span class="gyro-value" id="quatW">1.000</span>
                    </div>
                    <div class="gyro-item">
                        <span class="gyro-label">angular velocity:</span>
                        <span class="gyro-value" id="velocity">x:0, y:0, z:0</span>
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <h3>Cube Information</h3>
                <div class="cube-info">
                    <div class="info-item">
                        <span class="label">device name:</span>
                        <span class="value" id="deviceName">not connected</span>
                    </div>
                    <div class="info-item">
                        <span class="label">mac address:</span>
                        <span class="value" id="deviceMAC">--:--:--:--:--:--</span>
                    </div>
                    <div class="info-item">
                        <span class="label">generation:</span>
                        <span class="value" id="generation">unknown</span>
                    </div>
                    <div class="info-item">
                        <span class="label">hardware:</span>
                        <span class="value" id="hardware">unknown</span>
                    </div>
                    <div class="info-item">
                        <span class="label">battery:</span>
                        <span class="value" id="battery">--%</span>
                    </div>
                    <div class="info-item">
                        <span class="label">last move:</span>
                        <span class="value" id="lastMove">none</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="panel">
            <h3>Event Feed</h3>
            <div id="log" class="log"></div>
        </div>
        
        <div class="panel">
            <h3>Native Windows Gaming Controller</h3>
            <div style="margin: 15px 0;">
                <strong>Real Native Bluetooth Connection:</strong><br>
                <span style="color: #28a745;">âœ… Direct Windows Bluetooth API (no WSL2, no Web Bluetooth)</span><br>
                <span style="color: #007bff;">âš¡ Ultra-low latency (&lt;10ms cube-to-game)</span><br>
                <span style="color: #6f42c1;">ðŸŽ® Works with ALL games supporting Xbox controllers</span>
            </div>
            <div style="margin: 15px 0;">
                <strong>Controller Mapping:</strong><br>
                <span style="color: #007bff;">R = R1 (right bumper)</span> | 
                <span style="color: #007bff;">R' = R2 (right trigger)</span><br>
                <span style="color: #28a745;">L = B Button</span> | 
                <span style="color: #28a745;">L' = B Button</span><br>
                <span style="color: #ffc107;">D = X Button</span> | 
                <span style="color: #6f42c1;">B = R3 (right stick press)</span><br>
                <strong>Left Analog Stick:</strong> <span style="color: #dc3545;">Cube Tilt = Movement</span>
            </div>
            <div id="inputLog" style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 5px; font-family: monospace; font-size: 12px; max-height: 150px; overflow-y: auto;"></div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { TwistyPlayer } from 'https://cdn.cubing.net/v0/js/cubing/twisty';

        const SOLVED_STATE = "UUUUUUUUURRRRRRRRRFFFFFFFFFDDDDDDDDDLLLLLLLLLBBBBBBBBB";

        var twistyPlayer = new TwistyPlayer({
            puzzle: '3x3x3',
            visualization: 'PG3D',
            alg: 'y',
            experimentalSetupAnchor: 'start',
            background: 'none',
            controlPanel: 'none',
            hintFacelets: 'none',
            experimentalDragInput: 'none',
            cameraLatitude: 0,
            cameraLongitude: 0,
            cameraLatitudeLimit: 0,
            tempoScale: 5
        });

        $('#cube-twisty-player').append(twistyPlayer);

        let websocket = null;
        let controllerBridge = null;
        let moveCount = 0;
        let isScanning = false;
        let isConnected = false;
        let discoveredCubes = new Map();
        
        let basis = null;
        let cubeQuaternion = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, 0, 0));
        
        var twistyScene;
        var twistyVantage;
        
        const statusDiv = document.getElementById('status');
        const logDiv = document.getElementById('log');
        const inputLogDiv = document.getElementById('inputLog');
        const activityIndicator = document.getElementById('activityIndicator');
        
        // Cube Controller Input Mapping System
        const MOVE_MAPPINGS = {
            'R': { type: 'gamepad', action: 'R1', description: 'R1 (Right Bumper)' },
            "R'": { type: 'gamepad', action: 'R2', description: 'R2 (Right Trigger)' },
            'L': { type: 'gamepad', action: 'B', description: 'B Button' },
            "L'": { type: 'gamepad', action: 'B', description: 'B Button' },
            'D': { type: 'gamepad', action: 'X', description: 'X Button' },
            'B': { type: 'gamepad', action: 'R3', description: 'R3 (Right Stick Press)' },
            'F': { type: 'gamepad', action: 'DPAD_RIGHT', description: 'D-Pad Right' },
            "F'": { type: 'gamepad', action: 'DPAD_LEFT', description: 'D-Pad Left' }
        };
        
        // Orientation processing state
        let orientationState = {
            lastQuaternion: { x: 0, y: 0, z: 0, w: 1 },
            currentQuaternion: { x: 0, y: 0, z: 0, w: 1 },
            activeKeys: new Set(),
            mouseAccumulator: { x: 0, y: 0 },
            referenceOrientation: null,
            lastLogTime: 0
        };
        
        function logInput(message) {
            const timestamp = new Date().toLocaleTimeString();
            const entry = `<div style="margin: 2px 0; color: #666;">[${timestamp}] ${message}</div>`;
            inputLogDiv.innerHTML += entry;
            inputLogDiv.scrollTop = inputLogDiv.scrollHeight;
            
            const entries = inputLogDiv.querySelectorAll('div');
            if (entries.length > 15) {
                for (let i = 0; i < entries.length - 15; i++) {
                    entries[i].remove();
                }
            }
        }
        
        function processCubeMove(move) {
            const mapping = MOVE_MAPPINGS[move];
            
            if (!mapping) {
                logInput(`No mapping defined for move: ${move}`);
                return;
            }
            
            log(`CONTROLLER: ${move} = ${mapping.description}`);
            logInput(`Detected move: ${move} = ${mapping.description}`);
            
            // Send move to controller bridge for processing
            sendToControllerBridge({
                type: 'MOVE',
                move: move,
                mapping: mapping,
                timestamp: Date.now()
            });
        }

        function transformCubeQuaternion(rawQuat) {
            return new THREE.Quaternion(
                rawQuat.x,
                rawQuat.z,
                rawQuat.y,
                rawQuat.w
            ).normalize();
        }
        
        function processOrientation(quaternion) {
            const transformedQuat = new THREE.Quaternion(
                -quaternion.x,
                quaternion.z,
                quaternion.y,
                quaternion.w
            ).normalize();
            
            orientationState.currentQuaternion = { 
                x: transformedQuat.x,
                y: transformedQuat.y,
                z: transformedQuat.z,
                w: transformedQuat.w
            };
            
            if (!orientationState.referenceOrientation) {
                orientationState.referenceOrientation = { ...transformedQuat };
                logInput('Reference orientation set');
                return;
            }
            
            const refQuat = new THREE.Quaternion(
                orientationState.referenceOrientation.x,
                orientationState.referenceOrientation.y,
                orientationState.referenceOrientation.z,
                orientationState.referenceOrientation.w
            );
            
            const relative = transformedQuat.clone().multiply(refQuat.clone().invert());
            
            let rawTiltX = -relative.z * 4.0;
            let rawTiltY = -relative.x * 4.0;
            let rawSpinZ = -relative.y * 1.5;
            
            let tiltX = 0, tiltY = 0;
            const absX = Math.abs(rawTiltX);
            const absY = Math.abs(rawTiltY);
            
            if (absX > absY && absX > 0.15) {
                tiltX = Math.max(-1.0, Math.min(1.0, rawTiltX));
            } else if (absY > absX && absY > 0.15) {
                tiltY = Math.max(-1.0, Math.min(1.0, rawTiltY));
            }
            
            let spinZ = Math.max(-1.0, Math.min(1.0, rawSpinZ));
            
            const deadzone = 0.1;
            const spinDeadzone = 0.1;
            if (Math.abs(tiltX) < deadzone) tiltX = 0;
            if (Math.abs(tiltY) < deadzone) tiltY = 0;
            if (Math.abs(spinZ) < spinDeadzone) spinZ = 0;
            
            sendToControllerBridge({
                type: 'ORIENTATION',
                tiltX: tiltX,
                tiltY: tiltY,
                spinZ: spinZ,
                timestamp: Date.now()
            });
            
            if (Math.random() < 0.05) {
                if (Math.abs(tiltX) > 0.1 || Math.abs(tiltY) > 0.1 || Math.abs(spinZ) > 0.1) {
                    logInput(`Left Stick: X=${tiltX.toFixed(2)}, Y=${tiltY.toFixed(2)} | Right Stick: X=${spinZ.toFixed(2)}`);
                }
            }
            
            orientationState.lastQuaternion = { ...quaternion };
        }
        
        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            const entry = `<div class="log-entry">[${timestamp}] ${message}</div>`;
            logDiv.innerHTML += entry;
            logDiv.scrollTop = logDiv.scrollHeight;
            
            const entries = logDiv.querySelectorAll('.log-entry');
            if (entries.length > 30) {
                for (let i = 0; i < entries.length - 30; i++) {
                    entries[i].remove();
                }
            }
            
            console.log(message);
        }

        async function animateCubeOrientation() {
            if (!twistyScene || !twistyVantage) {
                var vantageList = await twistyPlayer.experimentalCurrentVantages();
                twistyVantage = [...vantageList][0];
                if (twistyVantage && twistyVantage.scene) {
                    twistyScene = await twistyVantage.scene.scene();
                }
            }
            if (twistyScene && twistyVantage) {
                twistyScene.quaternion.slerp(cubeQuaternion, 0.25);
                twistyVantage.render();
            }
            requestAnimationFrame(animateCubeOrientation);
        }
        requestAnimationFrame(animateCubeOrientation);

        function updateGyroDisplay(quaternion, velocity) {
            let { x: qx, y: qy, z: qz, w: qw } = quaternion;
            
            $('#quatX').text(qx.toFixed(3));
            $('#quatY').text(qy.toFixed(3));
            $('#quatZ').text(qz.toFixed(3));
            $('#quatW').text(qw.toFixed(3));
            
            let visualQuat = new THREE.Quaternion(
                -qx,
                qz,
                qy,
                qw
            ).normalize();
            
            if (!basis) {
                const correction = new THREE.Quaternion().setFromEuler(
                    new THREE.Euler(0, 2*Math.PI, 0)
                );
                
                basis = visualQuat.clone().invert().multiply(correction);
            }
            
            cubeQuaternion.copy(visualQuat.clone().multiply(basis));
            
            if (velocity) {
                $('#velocity').text(`x:${velocity.x.toFixed(2)}, y:${velocity.y.toFixed(2)}, z:${velocity.z.toFixed(2)}`);
            }
        }
                
        function resetOrientation() {
            basis = null;
            
            if (isConnected && orientationState.currentQuaternion) {
                orientationState.referenceOrientation = {
                    x: orientationState.currentQuaternion.x,
                    y: orientationState.currentQuaternion.y,
                    z: orientationState.currentQuaternion.z,
                    w: orientationState.currentQuaternion.w
                };
                
                logInput('Orientation reset - current position is now neutral');
            } else {
                orientationState.referenceOrientation = null;
                logInput('No cube connected or no orientation data yet');
            }
            
            for (const key of orientationState.activeKeys) {
                releaseKey(key);
            }
            orientationState.activeKeys.clear();
            orientationState.mouseAccumulator = { x: 0, y: 0 };
            
            log('Orientation reset! Current position is now neutral');
        }
                
        function updateCubeInfo(key, value) {
            const element = document.getElementById(key);
            if (element) {
                element.textContent = value;
            }
        }
        
        function updateStatus(message, connected = false, scanning = false) {
            statusDiv.textContent = `status: ${message}`;
            if (scanning) {
                statusDiv.className = 'status scanning';
                activityIndicator.className = 'activity-indicator scanning-indicator';
            } else if (connected) {
                statusDiv.className = 'status connected';
                activityIndicator.className = 'activity-indicator active';
            } else {
                statusDiv.className = 'status disconnected';
                activityIndicator.className = 'activity-indicator inactive';
            }
        }
        
        function connectWebSocket() {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                log('Already connected to native service');
                return;
            }
            
            try {
                websocket = new WebSocket('ws://localhost:8080');
                
                websocket.onopen = () => {
                    log('Connected to native Windows service');
                    updateStatus('native service connected', true);
                    
                    // Send ping to test connection
                    sendToNativeService({ type: 'PING' });
                };
                
                websocket.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        handleNativeServiceMessage(data);
                    } catch (error) {
                        log(`Error parsing message: ${error.message}`);
                    }
                };
                
                websocket.onclose = () => {
                    log('Native service connection closed');
                    updateStatus('native service disconnected', false);
                    isConnected = false;
                };
                
                websocket.onerror = (error) => {
                    log(`Native service error: ${error}`);
                };
                
            } catch (error) {
                log(`Failed to connect to native service: ${error}`);
            }
        }
        
        function handleNativeServiceMessage(data) {
            switch (data.type) {
                case 'PONG':
                    log('Native service ping successful');
                    break;
                    
                case 'CUBE_CONNECTED':
                    isConnected = true;
                    log(`Cube connected: ${data.cubeInfo.deviceName}`);
                    updateStatus('cube connected', true);
                    updateCubeInfo('deviceName', data.cubeInfo.deviceName);
                    updateCubeInfo('deviceMAC', data.cubeInfo.deviceMAC);
                    updateCubeInfo('generation', data.cubeInfo.generation);
                    hideCubeList();
                    break;
                    
                case 'CUBE_DISCONNECTED':
                    isConnected = false;
                    log('Cube disconnected');
                    updateStatus('cube disconnected', false);
                    updateCubeInfo('deviceName', 'not connected');
                    updateCubeInfo('deviceMAC', '--:--:--:--:--:--');
                    updateCubeInfo('generation', 'unknown');
                    updateCubeInfo('hardware', 'unknown');
                    updateCubeInfo('battery', '--%');
                    updateCubeInfo('lastMove', 'none');
                    resetGyroDisplay();
                    break;
                    
                case 'CUBE_FOUND':
                    addDiscoveredCube(data.cubeInfo);
                    break;
                    
                case 'SCANNING_STARTED':
                    isScanning = true;
                    updateStatus('scanning for cubes...', false, true);
                    showCubeList();
                    break;
                    
                case 'SCANNING_STOPPED':
                    isScanning = false;
                    if (!isConnected) {
                        updateStatus('scan complete', false);
                    }
                    break;
                    
                case 'MOVE':
                    moveCount++;
                    log(`Move #${moveCount}: ${data.move}`);
                    updateCubeInfo('lastMove', data.move);
                    twistyPlayer.experimentalAddMove(data.move, { cancel: false });
                    processCubeMove(data.move);
                    break;
                    
                case 'GYRO':
                    updateGyroDisplay(data.quaternion, data.velocity);
                    processOrientation(data.quaternion);
                    break;
                    
                case 'BATTERY':
                    updateCubeInfo('battery', `${data.batteryLevel}%`);
                    log(`Battery: ${data.batteryLevel}%`);
                    break;
                    
                case 'HARDWARE':
                    const hardwareInfo = `${data.hardwareName} v${data.hardwareVersion}`;
                    updateCubeInfo('hardware', hardwareInfo);
                    log(`Hardware: ${hardwareInfo}`);
                    break;
                    
                case 'FACELETS':
                    if (data.facelets != SOLVED_STATE) {
                        twistyPlayer.alg = data.facelets;
                    } else {
                        twistyPlayer.alg = '';
                    }
                    break;
                    
                case 'CONNECTION_FAILED':
                    log(`Cube connection failed: ${data.message}`);
                    updateStatus('connection failed', false);
                    break;
                    
                case 'ERROR':
                    log(`Error: ${data.message}`);
                    break;
                    
                default:
                    log(`Unknown message type: ${data.type}`);
            }
        }
        
        function sendToNativeService(data) {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                websocket.send(JSON.stringify(data));
                return true;
            } else {
                log('Native service not connected');
                return false;
            }
        }
        
        function connectControllerBridge() {
            try {
                controllerBridge = new WebSocket('ws://localhost:8082');
                
                controllerBridge.onopen = () => {
                    logInput('Connected to Windows input bridge');
                    logInput('Real system input now active');
                    log('Windows input bridge connected - ready for gaming');
                };
                
                controllerBridge.onclose = () => {
                    logInput('Windows input bridge disconnected');
                    logInput('Restart: python windows_input_server.py');
                    controllerBridge = null;
                };
                
                controllerBridge.onerror = (error) => {
                    logInput(`Controller bridge error: ${error}`);
                    console.error('WebSocket error:', error);
                };
                
            } catch (error) {
                logInput(`Failed to connect to controller bridge: ${error}`);
                console.error('Controller bridge connection error:', error);
            }
        }
        
        function sendToControllerBridge(data) {
            try {
                if (controllerBridge && controllerBridge.readyState === WebSocket.OPEN) {
                    controllerBridge.send(JSON.stringify(data));
                    return true;
                } else {
                    if (Math.random() < 0.1) {
                        logInput('Windows bridge not connected - using browser simulation only');
                    }
                    return false;
                }
            } catch (error) {
                console.error('Error sending to controller bridge:', error);
                logInput(`Bridge send error: ${error.message}`);
                return false;
            }
        }
        
        function connectCube() {
            if (isConnected) {
                log('Cube already connected!');
                return;
            }
            
            log('Requesting cube connection...');
            sendToNativeService({ type: 'CONNECT_CUBE' });
        }
        
        function scanForCubes() {
            if (isScanning) {
                log('Stopping cube scan...');
                sendToNativeService({ type: 'STOP_SCANNING' });
            } else {
                log('Starting cube scan...');
                discoveredCubes.clear();
                clearCubeList();
                sendToNativeService({ type: 'START_SCANNING' });
            }
        }
        
        function connectToSpecificCube(address) {
            log(`Connecting to cube: ${address}`);
            sendToNativeService({ 
                type: 'CONNECT_CUBE', 
                address: address 
            });
        }
        
        function disconnect() {
            if (websocket) {
                sendToNativeService({ type: 'DISCONNECT_CUBE' });
            }
            
            if (controllerBridge) {
                controllerBridge.close();
                controllerBridge = null;
                logInput('Controller bridge disconnected');
            }
            
            log('Disconnecting...');
        }
        
        function addDiscoveredCube(cubeInfo) {
            discoveredCubes.set(cubeInfo.address, cubeInfo);
            updateCubeList();
        }
        
        function showCubeList() {
            document.getElementById('cubeList').style.display = 'block';
            updateCubeList();
        }
        
        function hideCubeList() {
            document.getElementById('cubeList').style.display = 'none';
        }
        
        function clearCubeList() {
            document.getElementById('cubeItems').innerHTML = '';
        }
        
        function updateCubeList() {
            const cubeItems = document.getElementById('cubeItems');
            cubeItems.innerHTML = '';
            
            if (discoveredCubes.size === 0) {
                cubeItems.innerHTML = '<div style="color: #666; font-style: italic;">No cubes found yet...</div>';
                return;
            }
            
            discoveredCubes.forEach((cubeInfo, address) => {
                const item = document.createElement('div');
                item.className = 'cube-item';
                item.innerHTML = `
                    <div>
                        <div><strong>${cubeInfo.name}</strong></div>
                        <div class="cube-details">${address} | RSSI: ${cubeInfo.rssi}dBm</div>
                    </div>
                    <button onclick="connectToSpecificCube('${address}')">Connect</button>
                `;
                cubeItems.appendChild(item);
            });
        }
        
        function resetGyroDisplay() {
            $('#quatX').text('0.000');
            $('#quatY').text('0.000');
            $('#quatZ').text('0.000');
            $('#quatW').text('1.000');
            $('#velocity').text('x:0, y:0, z:0');
            basis = null;
            updateGyroDisplay({x: 0, y: 0, z: 0, w: 1}, {x: 0, y: 0, z: 0});
        }
        
        // Make functions globally available
        window.connectToSpecificCube = connectToSpecificCube;
        
        // Event listeners
        document.getElementById('connectCube').addEventListener('click', connectCube);
        document.getElementById('scanCubes').addEventListener('click', scanForCubes);
        document.getElementById('connectBridge').addEventListener('click', connectControllerBridge);
        document.getElementById('resetOrientation').addEventListener('click', resetOrientation);
        document.getElementById('disconnect').addEventListener('click', disconnect);
        
        // Initialize
        function initialize() {
            logInput('Native Windows GAN Cube Controller System Initialized');
            logInput('âœ… Real Bluetooth API - No WSL2 required');
            logInput('âš¡ Ultra-low latency gaming controller');
            logInput('ðŸŽ® Works with ALL Xbox controller compatible games');
            logInput('Connect to native service to begin...');
            
            // Auto-connect to native service
            setTimeout(connectWebSocket, 500);
        }
        
        // Update scan button text based on state
        setInterval(() => {
            const scanButton = document.getElementById('scanCubes');
            if (isScanning) {
                scanButton.textContent = 'Stop Scanning';
                scanButton.style.background = '#dc3545';
            } else {
                scanButton.textContent = 'Scan for Cubes';
                scanButton.style.background = '#007bff';
            }
        }, 100);
        
        initialize();
    </script>
</body>
</html>